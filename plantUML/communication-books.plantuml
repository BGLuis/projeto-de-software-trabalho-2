@startuml Diagrama de Comunicação - Consulta de Livros

title Diagrama de Comunicação - UC-07: Listar Livros com Filtros

' Objetos
object ":Cliente\nWeb" as Client
object ":BooksController" as Controller
object ":BooksService" as Service
object ":BookRepository" as BookRepo
object ":RedisCache" as Cache
object ":Database\nMySQL Slave" as DBSlave

' === UC-07: LISTAR LIVROS ===

Client -> Controller : **1:** GET /books?page=1&limit=20&status=ACTIVE&tags=action,romance
note right: Query parameters

Controller -> Service : **1.1:** findAll(queryDto)

Service -> Cache : **1.1.1:** get("books:page:1:limit:20:filters:...")
Cache --> Service : **1.1.2:** null (cache miss)

Service -> BookRepo : **1.1.3:** findAndCount({...filters, relations})
note right
    QueryBuilder com:
    - Paginação (skip, take)
    - Filtros (status, tags, authors)
    - Ordenação (createdAt DESC)
    - Relations (authors, tags, covers)
end note

BookRepo -> DBSlave : **1.1.3.1:** SELECT b.*, a.*, t.*, c.* FROM books b\nLEFT JOIN books_authors ba ...\nWHERE b.deleted_at IS NULL AND ...
note right: Read replica
DBSlave --> BookRepo : **1.1.3.2:** [booksData[], totalCount]
BookRepo --> Service : **1.1.4:** [books[], total]

Service -> Service : **1.1.5:** transformBooks(books)
note right
    - Mapear URLs das capas
    - Ocultar campos internos
    - Formatar dados
end note

Service -> Cache : **1.1.6:** set("books:page:...", result, TTL=5min)
Cache --> Service : **1.1.7:** OK

Service --> Controller : **1.2:** {data: books[], meta: {total, page, limit}}
Controller --> Client : **2:** 200 OK {data[], meta, links}

note bottom of Client
    **Fluxo UC-07: Listar Livros**
    1. Cliente envia parâmetros de filtro/paginação
    2. Sistema verifica cache Redis (5min TTL)
    3. Se cache miss, consulta banco slave (read)
    4. Aplica filtros: status, tags, autores, título
    5. Inclui relacionamentos (authors, tags, covers)
    6. Transforma dados e URLs
    7. Armazena resultado no cache
    8. Retorna com metadados de paginação

    **Otimizações:**
    - Cache por combinação de filtros
    - Read replica para não sobrecarregar master
    - Eager loading de relacionamentos
    - Soft delete (deleted_at IS NULL)
end note

@enduml

@startuml Diagrama de Comunicação - UC-09: Visualizar Detalhes

title Diagrama de Comunicação - UC-09: Visualizar Detalhes do Livro

' Objetos
object ":Cliente\nWeb" as Client
object ":BooksController" as Controller
object ":BooksService" as Service
object ":BookRepository" as BookRepo
object ":ChapterRepository" as ChapterRepo
object ":RedisCache" as Cache
object ":Database\nMySQL Slave" as DBSlave

' === UC-09: DETALHES DO LIVRO ===

Client -> Controller : **1:** GET /books/:id
note right: bookId

Controller -> Service : **1.1:** findOne(bookId)

Service -> Cache : **1.1.1:** get("book:details:" + bookId)
Cache --> Service : **1.1.2:** null (cache miss)

Service -> BookRepo : **1.1.3:** findOne({id, deletedAt: null}, {relations})
note right
    Relations:
    - authors
    - tags
    - covers
    - sensitiveContent
end note

BookRepo -> DBSlave : **1.1.3.1:** SELECT b.*, a.*, t.*, c.*, s.*\nFROM books b\nLEFT JOIN books_authors ba ON ...\nWHERE b.id=? AND b.deleted_at IS NULL
DBSlave --> BookRepo : **1.1.3.2:** bookData with relations
BookRepo --> Service : **1.1.4:** book

Service -> ChapterRepo : **1.1.5:** count({bookId, deletedAt: null})
ChapterRepo -> DBSlave : **1.1.5.1:** SELECT COUNT(*) FROM chapters WHERE book_id=? AND deleted_at IS NULL
DBSlave --> ChapterRepo : **1.1.5.2:** chapterCount
ChapterRepo --> Service : **1.1.6:** totalChapters

Service -> Service : **1.1.7:** enrichBookData(book, totalChapters)
note right
    - Adicionar contagem de capítulos
    - Formatar URLs das capas
    - Adicionar metadados
end note

Service -> Cache : **1.1.8:** set("book:details:" + bookId, enrichedBook, TTL=10min)
Cache --> Service : **1.1.9:** OK

Service --> Controller : **1.2:** enrichedBook
Controller --> Client : **2:** 200 OK {book details}

note bottom of Client
    **Fluxo UC-09: Detalhes do Livro**
    1. Cliente solicita detalhes de um livro
    2. Verifica cache Redis (10min TTL)
    3. Consulta banco slave com eager loading
    4. Carrega: authors, tags, covers, sensitiveContent
    5. Conta capítulos disponíveis
    6. Enriquece dados com metadados
    7. Cacheia resultado completo
    8. Retorna detalhes completos

    **Dados Incluídos:**
    - Informações básicas (título, descrição, status)
    - Lista de autores
    - Tags/categorias
    - Conteúdo sensível
    - Capas disponíveis
    - Total de capítulos
    - Datas de criação/atualização
end note

@enduml

@startuml Diagrama de Comunicação - UC-13: Visualizar Capítulo

title Diagrama de Comunicação - UC-13: Visualizar Capítulo

' Objetos
object ":Cliente\nWeb" as Client
object ":ChapterController" as Controller
object ":ChapterService" as Service
object ":ChapterRepository" as ChapterRepo
object ":PageRepository" as PageRepo
object ":RedisCache" as Cache
object ":Database\nMySQL Slave" as DBSlave

' === UC-13: VISUALIZAR CAPÍTULO ===

Client -> Controller : **1:** GET /chapters/:chapterId
note right: chapterId

Controller -> Service : **1.1:** findOne(chapterId)

Service -> Cache : **1.1.1:** get("chapter:" + chapterId + ":pages")
Cache --> Service : **1.1.2:** null (cache miss)

Service -> ChapterRepo : **1.1.3:** findOne({id: chapterId, deletedAt: null})
ChapterRepo -> DBSlave : **1.1.3.1:** SELECT * FROM chapters WHERE id=? AND deleted_at IS NULL
DBSlave --> ChapterRepo : **1.1.3.2:** chapterData
ChapterRepo --> Service : **1.1.4:** chapter

Service -> PageRepo : **1.1.5:** find({chapterId, deletedAt: null}, {order: {pageNumber: ASC}})
PageRepo -> DBSlave : **1.1.5.1:** SELECT * FROM pages\nWHERE chapter_id=? AND deleted_at IS NULL\nORDER BY page_number ASC
DBSlave --> PageRepo : **1.1.5.2:** pagesData[]
PageRepo --> Service : **1.1.6:** pages[]

Service -> Service : **1.1.7:** buildPageUrls(pages)
note right
    Gera URLs completas:
    /files/pages/{bookId}/{chapterId}/{pageNumber}.jpg
end note

Service -> Cache : **1.1.8:** set("chapter:" + chapterId + ":pages", {chapter, pages}, TTL=30min)
note right: Cache longo (páginas não mudam)
Cache --> Service : **1.1.9:** OK

Service --> Controller : **1.2:** {chapter, pages[]}
Controller --> Client : **2:** 200 OK {chapter, pages[]}

note bottom of Client
    **Fluxo UC-13: Visualizar Capítulo**
    1. Cliente solicita capítulo específico
    2. Verifica cache (TTL 30min)
    3. Consulta dados do capítulo
    4. Carrega todas as páginas ordenadas
    5. Gera URLs completas das imagens
    6. Cacheia capítulo + páginas
    7. Retorna para leitura

    **Otimizações:**
    - Cache longo (30min) - páginas imutáveis
    - Páginas ordenadas por número
    - URLs pré-geradas
    - Read replica

    **Dados Retornados:**
    - chapter.id, title, number
    - pages[].pageNumber
    - pages[].imageUrl
    - Total de páginas
end note

@enduml
